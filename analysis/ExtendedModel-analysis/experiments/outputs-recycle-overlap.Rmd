---
title: "outputs-recycle-overlap"
author: "Emily Coco"
date: "9/28/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(data.table)

theme_set(theme_minimal())

source("layers-data-prep.R")

layerdata = df

parameters = c("max_use_intensity", "max_artifact_carry", "max_flake_size","max_nodules_size", "blank_prob", "scavenge_prob", "overlap","mu", "size_preference", "flake_preference","min_suitable_flake_size", "strict_selection")
outputs = c("ri.cr.cor","ri.nc.cor","ri.fc.cor","ri.nd.cor","ri.ns.cor","ri.ne.cor","ri.nm.cor","ri.nr.cor","ri.no.cor","ri.av.cor")

```

## Do high values of recycling correspond with certain values of the other behaviors?

```{r relationships, warning=F, fig.dim=c(11, 5)}

plot_correlations = function(o) {
  p1 = ggplot(layerdata, aes(x = as.factor(blank_prob), y = get(o), color = as.factor(scavenge_prob))) +
  geom_boxplot() +
  facet_grid(max_use_intensity ~ max_artifact_carry, labeller = label_both) +
    labs(x = "blank prob", y = o, color = "scavenge prob") +
    theme(text = element_text(size = 6))
  
  p2 = ggplot(layerdata, aes(x = as.factor(max_flake_size), y = get(o), color = as.factor(max_nodules_size))) +
  geom_boxplot() +
  facet_grid(min_suitable_flake_size ~ size_preference + flake_preference + strict_selection, labeller = label_both) +
    labs(x = "max flake size", y = o, color = "max nod size") +
    theme(text = element_text(size = 6))
  
  p3 = ggplot(layerdata, aes(x = as.factor(blank_prob), y = get(o), color = as.factor(scavenge_prob))) +
  geom_boxplot() +
  facet_grid(overlap ~ mu, labeller = label_both) +
    labs(x = "blank prob", y = o, color = "scavenge prob") +
    theme(text = element_text(size = 6))
  
  return(list(p1, p3, p2))
}

for(o in outputs) {

  plots = plot_correlations(o)
  plot(cowplot::plot_grid(plots[[1]], plots[[2]], plots[[3]]))

  
}



```

## How are the relationships between recycling intensity and other behaviors impacted by experimental parameters?
```{r correlations, warning=F, include=F, eval=F}
library(corrplot)

plot_correlogram = function(cordata, title) { 
  cormat = cor(cordata, use = "complete.obs")
  
  cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
      for (j in (i + 1):n) {
        tmp <- cor.test(mat[, i], mat[, j], ...)
        p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
      }
    }
    colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
    p.mat
  }
  # matrix of the p-value of the correlation
  p.mat <- cor.mtest(cordata)
  
  col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
  return(corrplot(cormat, method="color", col=col(200),  
                  type="upper", order="hclust", 
                  addCoef.col = "black", # Add coefficient of correlation
                  tl.col="black", tl.srt=45, #Text label color and rotation
                  # Combine with significance
                  p.mat = p.mat, sig.level = 0.05, insig = "blank",
                  number.cex = 0.5, 
                  # hide correlation coefficient on the principal diagonal
                  diag=FALSE, title=title
                  )
         )
}



for(p in parameters) {
  values = c(unique(layerdata[p]))
  for(v in values[[1]]) {
    cordata = layerdata %>% filter(!!as.name(p) == v) %>% select(outputs)
    title = paste(p, ":", v)
    plot_correlogram(cordata, title)
  }
}


#possibly add in some indication of how different correlation matrices are based on parameters
#r values to z scores between recycling and each of the outputs
#regression on z scores?

cor.by.exp = layerdata %>% group_by_at(vars(one_of(parameters))) %>% 
  summarize(ri.cr.cor = cor(recycling.intensity, cortex.ratio, use ="complete.obs"),
            ri.nc.cor = cor(recycling.intensity, nodule.count, use ="complete.obs"),
            ri.fc.cor = cor(recycling.intensity, flake.count, use ="complete.obs"),
            ri.nd.cor = cor(recycling.intensity, num.discards, use ="complete.obs"),
            ri.ns.cor = cor(recycling.intensity, num.scavenge, use ="complete.obs"),
            ri.ne.cor = cor(recycling.intensity, num.encounters, use ="complete.obs"),
            ri.nm.cor = cor(recycling.intensity, num.manufacture, use ="complete.obs"),
            ri.nr.cor = cor(recycling.intensity, num.retouch, use ="complete.obs"),
            ri.no.cor = cor(recycling.intensity, num.retouch, use ="complete.obs"),
            ri.av.cor = cor(recycling.intensity, assemblage.vol, use ="complete.obs"),
            )


#regression of recycling intensity and cortex ratio correlation
model1 = lm(ri.cr.cor ~ max_use_intensity + max_artifact_carry + max_flake_size + max_nodules_size + blank_prob + scavenge_prob + overlap + mu + size_preference + flake_preference + min_suitable_flake_size + strict_selection, data = cor.by.exp)
summary(model1)

#regression of recycling intensity and flake count correlation
model2 = lm(ri.fc.cor ~ max_use_intensity + max_artifact_carry + max_flake_size + max_nodules_size + blank_prob + scavenge_prob + overlap + mu + size_preference + flake_preference + min_suitable_flake_size + strict_selection, data = cor.by.exp)
summary(model1)



```


